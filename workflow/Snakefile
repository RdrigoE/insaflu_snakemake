import sys
from scripts.check_file_validity import is_fasta, is_genbank, same_identifiers
from scripts.import_user_data import Data, get_data_in_align_form
from scripts.yaml_io import read_yaml, write_yaml
from scripts.extract_gb_info import (
    get_locus,
    get_id_version,
    get_locus_and_genes,
    get_genes,
    get_identification_version,
    get_identification_version_string,
)
from scripts.get_software_parameters import (
    get_nanofilt_parameters,
    mask_regions_parameters,
    get_trimmomatic_parameters,
    get_snippy_parameters,
)
import yaml
import re
import csv
import os
from validation.project import validate_project_settings


workdir: "./results/"

include: "../workflow/checkpoints/pangolin.smk"
include: "../workflow/checkpoints/main.smk"

# import all the files

# constants
dic_directory = read_yaml("../config/constants.yaml")

# used in some rules:
scripts_directory = dic_directory["scripts"]
coverage_script = dic_directory["get_coverage"]

# used for configuration
user_metadata_directory = dic_directory["user_metadata"]
software_parameters_path = dic_directory["software_parameters"]

config = read_yaml(dic_directory["threads"])

# project settings
user_metadata = read_yaml(dic_directory["sample_yaml"])

paths_dir = {
    "project_dir": "./projects/",
    "reference_dir": dic_directory["references"],
    "primer_dir": dic_directory["primers"],
}

errors = validate_project_settings(user_metadata, paths_dir)
if len(errors) != 0:
    print("-" * 80)
    print(f"The file '{dic_directory['sample_yaml']}' as the following errors:")
    for error, text in errors.items():
        print(f"\t{error}")
        print(f"\t\t{text}")
    print("-" * 80)
    sys.exit(
        "There are erros in the '{dic_directory['sample_yaml']}', fix them to procced."
    )


# sample_data
sample_data = Data(dic_directory["sample_csv"], user_metadata["illumina_consensus"])

(
    paired_illumina,
    single_illumina,
    ont_samples,
    samples,
) = sample_data.get_options()

illumina_samples = [*paired_illumina.keys(), *single_illumina.keys()]

illumina_assembler = sample_data.get_assembler()
(
    paired_illumina_snippy,
    single_illumina_snippy,
    paired_illumina_ivar,
    single_illumina_ivar,
) = get_data_in_align_form(illumina_assembler, single_illumina, paired_illumina)


memory = read_yaml(dic_directory["memory"])

# Runtime Variables
ABRICATE = user_metadata["abricate"]
REFERENCE_GB = paths_dir["reference_dir"] + user_metadata["gb_reference"]
REFERENCE_FASTA = paths_dir["reference_dir"] + user_metadata["fasta_reference"]
SEGMENTS = get_locus(REFERENCE_GB)
REFERENCE_NAME = re.findall("(?<=references/)(.*?)(?=.fasta)", REFERENCE_FASTA)[0]
PROJECT_NAME = user_metadata["project_name"]
PRIMER_FASTA = (
    paths_dir["primer_dir"] + user_metadata.get("primers_fasta")
    if user_metadata.get("primers_fasta") is not None
    else False
)

CONSENSUS_TOOL = user_metadata["illumina_consensus"]

identification, version = get_identification_version(SEGMENTS, REFERENCE_GB)

config_user = {
    "samples": samples,
    "project": user_metadata["project_name"],
    "locus": get_locus(REFERENCE_GB),
    "proteins": get_genes(REFERENCE_GB),
    "identification": identification,
    "version": version,
    "sample_type": sample_data.get_sample_type(),
}

write_yaml(dic_directory["config_file"], config_user)

software_parameters = read_yaml(dic_directory["software_parameters"])


# Pipeline
include: "rules/common.smk"
include: "rules/warnings.smk"
# Pipeline Samples
include: "rules/read_quality_analysis_and_improvement.smk"
include: "rules/type_and_subtype_classification.smk"
# Pipeline Projects
include: "rules/make_project.smk"
include: "rules/variant_detection_and_consensus_generation.smk"
include: "rules/coverage_analysis.smk"
include: "rules/alignment_and_phylogeny.smk"
include: "rules/intra_host_minor_variant_detection.smk"
# Extra SARS-CoV-2 Step
include: "rules/pangolin.smk"
# Include the functions that will determine the outputs
include: "outputs.smk"


get_output = (
    get_output_sample if user_metadata["only_samples"] is True else get_output_project
)


rule all:
    input:
        get_output(
            paired_illumina=paired_illumina.keys(),
            single_illumina=single_illumina.keys(),
            ont_samples=ont_samples.keys(),
            classification=ABRICATE,
            illumina_vc_software=illumina_assembler,
            project_name=PROJECT_NAME,
            min_coverage=software_parameters["min_coverage_consensus"],
            reference_gb=REFERENCE_GB,
        ),
